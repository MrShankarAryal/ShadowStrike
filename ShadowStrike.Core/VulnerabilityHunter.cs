using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;
using OpenQA.Selenium;

namespace ShadowStrike.Core
{
    public class Vulnerability
    {
        public string Type { get; set; } = "";
        public string Location { get; set; } = "";
        public string Description { get; set; } = "";
        public string Severity { get; set; } = "";
        public bool Exploitable { get; set; }
    }

    public class VulnerabilityHunter
    {
        private IWebDriver _driver;
        private HttpClient _httpClient = new HttpClient();

        public VulnerabilityHunter(IWebDriver driver)
        {
            _driver = driver;
        }

        public async Task<List<Vulnerability>> FindAllWeaknesses(string url)
        {
            var weaknesses = new List<Vulnerability>();

            // 1. Check for exposed admin panels
            weaknesses.AddRange(await FindExposedAdminPanels(url));

            // 2. Check for directory listing
            weaknesses.AddRange(await FindDirectoryListing(url));

            // 3. Check for exposed configuration files
            weaknesses.AddRange(await FindExposedConfigFiles(url));

            // 4. Check for weak authentication
            weaknesses.AddRange(await FindWeakAuth(url));

            // 5. Check for CORS misconfigurations
            weaknesses.AddRange(await FindCORSIssues(url));

            // 6. Check for missing security headers
            weaknesses.AddRange(await FindMissingSecurityHeaders(url));

            // 7. Check for subdomain takeover
            weaknesses.AddRange(await FindSubdomainTakeover(url));

            // 8. Check for open redirects
            weaknesses.AddRange(await FindOpenRedirects(url));

            return weaknesses;
        }

        private async Task<List<Vulnerability>> FindExposedAdminPanels(string url)
        {
            var weaknesses = new List<Vulnerability>();
            var baseUri = new Uri(url);
            var baseUrl = $"{baseUri.Scheme}://{baseUri.Host}";

            var adminPaths = new[]
            {
                "/admin", "/administrator", "/wp-admin", "/admin.php",
                "/admin/login", "/adminpanel", "/control", "/cpanel",
                "/dashboard", "/manager", "/phpmyadmin", "/admin/index.php"
            };

            foreach (var path in adminPaths)
            {
                try
                {
                    var response = await _httpClient.GetAsync(baseUrl + path);
                    if (response.IsSuccessStatusCode)
                    {
                        weaknesses.Add(new Vulnerability
                        {
                            Type = "Exposed Admin Panel",
                            Location = baseUrl + path,
                            Description = $"Admin panel accessible at {path}",
                            Severity = "Medium",
                            Exploitable = true
                        });
                    }
                }
                catch { }
            }

            return weaknesses;
        }

        private async Task<List<Vulnerability>> FindDirectoryListing(string url)
        {
            var weaknesses = new List<Vulnerability>();
            var baseUri = new Uri(url);
            var baseUrl = $"{baseUri.Scheme}://{baseUri.Host}";

            var directories = new[] { "/uploads/", "/images/", "/files/", "/backup/", "/temp/", "/logs/" };

            foreach (var dir in directories)
            {
                try
                {
                    var response = await _httpClient.GetAsync(baseUrl + dir);
                    var content = await response.Content.ReadAsStringAsync();

                    if (content.Contains("Index of") || content.Contains("Directory listing"))
                    {
                        weaknesses.Add(new Vulnerability
                        {
                            Type = "Directory Listing Enabled",
                            Location = baseUrl + dir,
                            Description = "Directory browsing is enabled, exposing file structure",
                            Severity = "Medium",
                            Exploitable = true
                        });
                    }
                }
                catch { }
            }

            return weaknesses;
        }

        private async Task<List<Vulnerability>> FindExposedConfigFiles(string url)
        {
            var weaknesses = new List<Vulnerability>();
            var baseUri = new Uri(url);
            var baseUrl = $"{baseUri.Scheme}://{baseUri.Host}";

            var configFiles = new[]
            {
                "/.env", "/config.php", "/configuration.php", "/wp-config.php",
                "/.git/config", "/composer.json", "/package.json", "/.htaccess",
                "/web.config", "/database.yml", "/.env.local", "/.env.production"
            };

            foreach (var file in configFiles)
            {
                try
                {
                    var response = await _httpClient.GetAsync(baseUrl + file);
                    if (response.IsSuccessStatusCode)
                    {
                        var content = await response.Content.ReadAsStringAsync();
                        if (content.Length > 0 && !content.Contains("404") && !content.Contains("Not Found"))
                        {
                            weaknesses.Add(new Vulnerability
                            {
                                Type = "Exposed Configuration File",
                                Location = baseUrl + file,
                                Description = $"Sensitive configuration file exposed: {file}",
                                Severity = "Critical",
                                Exploitable = true
                            });
                        }
                    }
                }
                catch { }
            }

            return weaknesses;
        }

        private async Task<List<Vulnerability>> FindWeakAuth(string url)
        {
            var weaknesses = new List<Vulnerability>();

            try
            {
                _driver.Navigate().GoToUrl(url);
                await Task.Delay(2000);

                // Check for login forms
                var loginForms = _driver.FindElements(By.CssSelector("form[action*='login'], form[action*='signin'], input[type='password']"));

                if (loginForms.Count > 0)
                {
                    // Check if HTTPS
                    if (!url.StartsWith("https://"))
                    {
                        weaknesses.Add(new Vulnerability
                        {
                            Type = "Insecure Authentication",
                            Location = url,
                            Description = "Login form transmitted over HTTP (not HTTPS)",
                            Severity = "Critical",
                            Exploitable = true
                        });
                    }

                    // Check for autocomplete enabled
                    foreach (var form in loginForms)
                    {
                        var autocomplete = form.GetAttribute("autocomplete");
                        if (autocomplete != "off")
                        {
                            weaknesses.Add(new Vulnerability
                            {
                                Type = "Weak Authentication",
                                Location = url,
                                Description = "Password autocomplete enabled (credential theft risk)",
                                Severity = "Low",
                                Exploitable = false
                            });
                        }
                    }
                }
            }
            catch { }

            return weaknesses;
        }

        private async Task<List<Vulnerability>> FindCORSIssues(string url)
        {
            var weaknesses = new List<Vulnerability>();

            try
            {
                var request = new HttpRequestMessage(HttpMethod.Options, url);
                request.Headers.Add("Origin", "https://evil.com");
                
                var response = await _httpClient.SendAsync(request);
                
                if (response.Headers.Contains("Access-Control-Allow-Origin"))
                {
                    var allowOrigin = response.Headers.GetValues("Access-Control-Allow-Origin").FirstOrDefault();
                    if (allowOrigin == "*" || allowOrigin == "https://evil.com")
                    {
                        weaknesses.Add(new Vulnerability
                        {
                            Type = "CORS Misconfiguration",
                            Location = url,
                            Description = "Permissive CORS policy allows any origin",
                            Severity = "High",
                            Exploitable = true
                        });
                    }
                }
            }
            catch { }

            return weaknesses;
        }

        private async Task<List<Vulnerability>> FindMissingSecurityHeaders(string url)
        {
            var weaknesses = new List<Vulnerability>();

            try
            {
                var response = await _httpClient.GetAsync(url);
                var headers = response.Headers;

                if (!headers.Contains("X-Frame-Options"))
                {
                    weaknesses.Add(new Vulnerability
                    {
                        Type = "Missing Security Header",
                        Location = url,
                        Description = "X-Frame-Options header missing (clickjacking risk)",
                        Severity = "Medium",
                        Exploitable = true
                    });
                }

                if (!headers.Contains("X-Content-Type-Options"))
                {
                    weaknesses.Add(new Vulnerability
                    {
                        Type = "Missing Security Header",
                        Location = url,
                        Description = "X-Content-Type-Options header missing (MIME sniffing risk)",
                        Severity = "Low",
                        Exploitable = false
                    });
                }

                if (!headers.Contains("Strict-Transport-Security"))
                {
                    weaknesses.Add(new Vulnerability
                    {
                        Type = "Missing Security Header",
                        Location = url,
                        Description = "HSTS header missing (man-in-the-middle risk)",
                        Severity = "Medium",
                        Exploitable = true
                    });
                }
            }
            catch { }

            return weaknesses;
        }

        private async Task<List<Vulnerability>> FindSubdomainTakeover(string url)
        {
            var weaknesses = new List<Vulnerability>();
            // This would require DNS lookups - simplified for now
            return weaknesses;
        }

        private async Task<List<Vulnerability>> FindOpenRedirects(string url)
        {
            var weaknesses = new List<Vulnerability>();

            var redirectParams = new[] { "url", "redirect", "next", "return", "returnUrl", "goto", "target" };

            foreach (var param in redirectParams)
            {
                try
                {
                    var testUrl = $"{url}?{param}=https://evil.com";
                    var response = await _httpClient.GetAsync(testUrl);
                    
                    if (response.RequestMessage?.RequestUri?.Host == "evil.com")
                    {
                        weaknesses.Add(new Vulnerability
                        {
                            Type = "Open Redirect",
                            Location = url,
                            Description = $"Open redirect vulnerability via '{param}' parameter",
                            Severity = "Medium",
                            Exploitable = true
                        });
                    }
                }
                catch { }
            }

            return weaknesses;
        }
    }
}
